# 消费者
1. 消费者必须通过AMQP的basic.ack命令显示地向Rabbitmq发送一个确认，或者在订阅到队列的时候就将auto_ack参数设置为true。当设置了auto_ack时，一旦消费者接收消息，Rabbitmq会自动视为其确认了消息。
2. 如果消费者受到一条消息，然后确认之前从rabbitmq断开连接(或者队列上取消订阅)，rabbitmq会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。如果你的应用崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理
3. 如果应用程序有bug而忘记确认消息的话，rabbitmq将不会给该消费者发送更多的消息了，这是因为在上一条消息被确认之前，rabbitmq会认为这个消费者并没有准备接收下一条消息。如果处理的消息内容非常耗时，则你的应用程序可以延迟确认该消息，直到消息处理完成，这样可以防止rabbitmq持续不断的消息涌向你的应用而导致过载
4. 收到消息后，如果要明确拒绝而不是确认消息
	* 把消费者从rabbitmq服务器断开连接,这会导致rabbitmq自动重新把消息入队并发送给给另一个消费者。这样做的好处是所有rabbitmq都支持。缺点是这样连接/断开连接的方式会额外增大rabbitmq的负担
	* rabbitmq2.0或者更新的版本，使用amqp的basic.reject命令(允许消费者拒绝rabbitmq发送的消息)。如果把reject命令的requeue参数设置为true，rabbitmq会将消息重新发送给下一个订阅的消费者


# 生产者
1.  队列参数
	* exclusive————exclusive 如果设置为true，队列将变成私有的，此时只有你的应用可以消费队列消息，如果想限制一个队列只有一个消费者时很有用
	* auto-delete————当最后一个消费者取消订阅的时候，队列就会自动删除。如果需要临时队列只为一个消费者服务的话，结合使用auto-delete和exclusive。当消费者断开连接时，队列就被移除了
2. 消息的生产者发送出去的消息如果路由到了不存在的队列，rabbitmq会忽略它们(进入黑洞而丢失)

# 消息持久化
1. 如果消息想要从rabbitmq崩溃中恢复，必须满足
	* 把它的投递模式(delivery mode)选项设置为2(持久)
	* 发送到持久化的交换器
	* 达到持久化的队列
2. rabbitmq确保持久性消息能从服务器中重启中恢复的方式是，将他们写入磁盘上的一个持久化日志文件。当发布一条持久化消息到持久交换器上时，rabbitmq会在消息提交到日志文件后才发送响应（如果之后这条消息路由到非持久化队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复）
3. 一旦你从持久化队列中消费了一条持久性消息的话(并且确认了它)，rabbitmq会在持久化日志中把这条消息标记为等待垃圾收集



# 发送方确认模式
1. 需要告诉rabbitmq将信道设置为confirm模式，而且你只能通过重新创建信道来关闭该设置。一旦信道进入confirm模式，所有在信道上发布的消息都被指派一个唯一的ID号(从1开始)。一旦消息被投递给所有匹配的队列后，信道会发送一个发送方确认模式给生产者应用程序(包括消息的唯一ID)。如果消息和队列是可持久化的，那么确认消息只会在队列将消息写入磁盘后才会发出，发送方确认模式的最大好处是他们是异步的。如果rabbitmq发生内部错误从而导致了消息的丢失，rabbitmq会发送一条nack(not acknowledged未确认)消息。就像发送方确认消息那样，只不过这次说明的是消息已经丢失

