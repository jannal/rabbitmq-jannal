# 订阅消息
1. 代码
    
    ```java
    channel.basicConsume("jannal.queue",true,"consumerTag",new DefaultConsumer(channel){
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                        super.handleDelivery(consumerTag, envelope, properties, body);
                        String routingKey =envelope.getRoutingKey();
                        String contentType = properties.getContentType();
                        long deliveryTag =envelope.getDeliveryTag();
                        // (process the message components here ...)
                        ///channel.basicAck(deliveryTag, false);
                        System.out.print(new String(body,"utf-8"));
                    }
                });
    ```
2. 核心代码分析


# Consumer
1. 消费者接口，默认的实现类是`DefaultConsumer`,`DefaultConsumer`只有`Channel`和`consumerTag`以及一些空的实现，可以认为这是一个适配器，具体要做什么处理由调用方自己决定





## 抓包分析
1. `Basic.Consumer`
![](image/15198255105813.jpg)

2. `Basic.Deliver`
    * 从下图可以看出`Rabbitmq Server`返回的协议格式为`[Method][Method][Content Header][Content body]`
    * ![](image/15198256912845.jpg)


    * ![](image/15198257185167.jpg)

    * ![](image/15198257437669.jpg)

## 核心方法分析
1. `basicConsume`
    
    ```java
    /**
     * 1.启动消费者，调用消费者的handlerConsumerOk
     * 2.queue 队列名称
     * 3. autoAck 自动ack
     * 4.consumerTag 不同的订阅采用Consumer Tag作为区分，在同一个Channel中的Consumer也需要通过唯一的Consumer tag以区分
     * 5. Consumer 回调接口
     */
    /** Public API - {@inheritDoc} */
    @Override
    public String basicConsume(String queue, final boolean autoAck, String consumerTag,
                               boolean noLocal, boolean exclusive, Map<String, Object> arguments,
                               final Consumer callback)
        throws IOException
    {
        //Future泛型对象是一个actualConsumerTag
        BlockingRpcContinuation<String> k = new BlockingRpcContinuation<String>() {
            @Override
            public String transformReply(AMQCommand replyCommand) {
                String actualConsumerTag = ((Basic.ConsumeOk) replyCommand.getMethod()).getConsumerTag();
                //保存consumerTag与Consumer的关联
                _consumers.put(actualConsumerTag, callback);

                // need to register consumer in stats before it actually starts consuming
                metricsCollector.basicConsume(ChannelN.this, actualConsumerTag, autoAck);

                //分发器，启动线程进行消费
                dispatcher.handleConsumeOk(callback, actualConsumerTag);
                return actualConsumerTag;
            }
        };

        rpc(new Basic.Consume.Builder()
             .queue(queue)
             .consumerTag(consumerTag)
             .noLocal(noLocal)
             .noAck(autoAck)
             .exclusive(exclusive)
             .arguments(arguments)
            .build(),
            k);

        try {
            return k.getReply();
        } catch(ShutdownSignalException ex) {
            throw wrap(ex);
        }
    }    
    
    ```
    
2. `rpc`分析
    * `quiescingRpc`
    
        ```java
          public void quiescingRpc(Method m, RpcContinuation k)
            throws IOException
        {
            //通道互斥锁,enqueueRpc和quiescingTransmit也加互斥锁
            synchronized (_channelMutex) {
                enqueueRpc(k);
                quiescingTransmit(m);
            }
        }
    
        ```
    * `enqueueRpc`
        
        ```java
         public void enqueueRpc(RpcContinuation k)
        {
            synchronized (_channelMutex) {
                boolean waitClearedInterruptStatus = false;
                //如果不为空此时等待，在nextOutstandingRpc时恢复初始状态null
                while (_activeRpc != null) {
                    try {
                        _channelMutex.wait();
                    } catch (InterruptedException e) {
                        waitClearedInterruptStatus = true;
                    }
                }
                if (waitClearedInterruptStatus) {
                    Thread.currentThread().interrupt();
                }
                _activeRpc = k;
            }
        }
        ```
    
    * `quiescingTransmit`
    
        ```java
        public void quiescingTransmit(Method m) throws IOException {
            synchronized (_channelMutex) {
                quiescingTransmit(new AMQCommand(m));
            }
        }

        public void quiescingTransmit(AMQCommand c) throws IOException {
            synchronized (_channelMutex) {
                if (c.getMethod().hasContent()) {
                    while (_blockContent) {
                        try {
                            _channelMutex.wait();
                        } catch (InterruptedException ignored) {}
    
                        // This is to catch a situation when the thread wakes up during
                        // shutdown. Currently, no command that has content is allowed
                        // to send anything in a closing state.
                        ensureIsOpen();
                    }
                }
                c.transmit(this);
            }
        }
        ```

