# 参数
[TOC]

## delivery-mode
1. `delivery-mode`设置为1(非持久化),设置为2(持久化)

## 消息确认
1. 如果在发送的时候，将`no-ack`设置为true，服务器就会在消息发送给客户端后自动将其出队。如果由于某些原因连接中断了，或者你的客户端应用程序发生故障了，那么该消息就永远丢失了。
2. 如果在订阅队列时将`no-ack`设置为true的话，那么你处理完消息之后就无需再发送确认消息回服务器(这样就能极大地加快消费者消费的速度)

## 投递消息
1. 如果发布的消息中`mandatory`和`immediate`标记设置为false的话，那么这个过程会以异步的方式执行，并且从客户端的角度来看，服务器会变得更快。




## Prefetch
1. 实际使用RabbitMQ过程中，如果完全不配置QoS，这样Rabbit会尽可能快速地发送队列中的所有消息到client端。因为consumer在本地缓存所有的message，从而极有可能导致OOM或者导致服务器内存不足影响其它进程的正常运行。所以我们需要通过设置Qos的`prefetch count`来控制consumer的流量。同时设置得当也会提高consumer的吞吐量。
2. prefetch允许为每个consumer指定最大的`unacked messages`数目。简单来说就是用来指定一个consumer一次可以从Rabbit中获取多少条message并缓存在client中(RabbitMQ提供的各种语言的client library)。一旦缓冲区满了，Rabbit将会停止投递新的message到该consumer中直到它发出ack
3. 假设prefetch值设为10，共有两个consumer。意味着每个consumer每次会从queue中预抓取 10 条消息到本地缓存着等待消费。同时该channel的unacked数变为20。而Rabbit投递的顺序是，先为consumer1投递满10个message，再往consumer2投递10个message。如果这时有新message需要投递，先判断channel的unacked数是否等于20，如果是则不会将消息投递到consumer中，message继续呆在queue中。之后其中consumer对一条消息进行ack，unacked此时等于19，Rabbit就判断哪个consumer的unacked少于10，就投递到哪个consumer中。
4. 总的来说，consumer负责不断处理消息，不断ack，然后只要unacked数少于prefetch * consumer数目，broker就不断将消息投递过去。
5. spring-amqp配置

```java
  spring-amqp中的prefetch默认值是1。
  <rabbit:listener-container connection-factory="connectionFactory" acknowledge="auto"
                               max-concurrency="1000" concurrency="100"
                               message-converter="messageConverter" prefetch="1"    >
        <rabbit:listener ref="commonMessageListener"  queue-names="jannal.queue"   />

    </rabbit:listener-container>

```
6. prefetch的设置与以下几点有关：
	* 客户端服务端之间网络传输时间
	* consumer消耗一条消息所执行的业务逻辑的耗时
	* 网络状况
	* 参考官方说明 https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/

	
	
	# 死信队列

1. `DLX(Dead-Letter-Exchange)`称之为死信队列。当一个消息在`Queue`中编程`死信消息(Dead Message)`之后，它能够被重新发送到另一个`Exchange`中，这个`Exchange`就是`DLX`,绑定`DLX`的队列就叫做`死信队列`
2. 消息变为死信队列
	* 消息被拒绝(`Basic.Reject/Basic.Nack`)，并且设置`requeue`参数为false
	* 消息过期
	* 队列达到最大长度

# 延迟队列

1. 
	



# ### Message acknowledgment
1. 消息回执。
	* 消费者受到Queue中的消息，但没有处理完成就宕机(或者其他情况)，这种情况会导致消息丢失，为了避免这个问题，可以要求消费者在处理完消息之后发送一个ack(回执)给rabbitmq。rabbitmq收到消息回执之后才将消息从Queue中移除。
	* 如果没有收到消息回执并检测到消费者的rabbitmq连接断开，则rabbitmq会将消息发送给其他消费者进行处理。这里不存在timeout，一个消费者处理消息时间再长也不会导致该消息被发送给其他消息者，除非他的rabbitmq连接断开。  
	* 如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的bug——Queue中堆积的消息会越来越多。消费者重启后会重复消费这些消息并重复执行业务逻辑。
2. publish message 是没有ACK的。

### Message durability
1. 可以将Queue与Message 都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的rabbitmq消息不会丢失(加入还没来及的持久化就宕机则依然会丢失)

### Prefetch count
1. 如果多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者，如果每个消息的处理时间不同，就可能导致一些消费者一直在忙，而另外一些消费者一直在空闲。可以通过设置Prefetch count来限制Queue每次发送给每个消费者的消息数，比如设置为1，则Queue每次给每个消费者发送一条消息，消费者处理完这条消息后Queue会再给该消费者发送一条消息。


# 消费者
1. 消费者必须通过AMQP的basic.ack命令显示地向Rabbitmq发送一个确认，或者在订阅到队列的时候就将auto_ack参数设置为true。当设置了auto_ack时，一旦消费者接收消息，Rabbitmq会自动视为其确认了消息。
2. 如果消费者受到一条消息，然后确认之前从rabbitmq断开连接(或者队列上取消订阅)，rabbitmq会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。如果你的应用崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理
3. 如果应用程序有bug而忘记确认消息的话，rabbitmq将不会给该消费者发送更多的消息了，这是因为在上一条消息被确认之前，rabbitmq会认为这个消费者并没有准备接收下一条消息。如果处理的消息内容非常耗时，则你的应用程序可以延迟确认该消息，直到消息处理完成，这样可以防止rabbitmq持续不断的消息涌向你的应用而导致过载
4. 收到消息后，如果要明确拒绝而不是确认消息
	* 把消费者从rabbitmq服务器断开连接,这会导致rabbitmq自动重新把消息入队并发送给给另一个消费者。这样做的好处是所有rabbitmq都支持。缺点是这样连接/断开连接的方式会额外增大rabbitmq的负担
	* rabbitmq2.0或者更新的版本，使用amqp的basic.reject命令(允许消费者拒绝rabbitmq发送的消息)。如果把reject命令的requeue参数设置为true，rabbitmq会将消息重新发送给下一个订阅的消费者


# 生产者
1.  队列参数
	* exclusive————exclusive 如果设置为true，队列将变成私有的，此时只有你的应用可以消费队列消息，如果想限制一个队列只有一个消费者时很有用
	* auto-delete————当最后一个消费者取消订阅的时候，队列就会自动删除。如果需要临时队列只为一个消费者服务的话，结合使用auto-delete和exclusive。当消费者断开连接时，队列就被移除了
2. 消息的生产者发送出去的消息如果路由到了不存在的队列，rabbitmq会忽略它们(进入黑洞而丢失)

# 消息持久化
1. 如果消息想要从rabbitmq崩溃中恢复，必须满足
	* 把它的投递模式(delivery mode)选项设置为2(持久)
	* 发送到持久化的交换器
	* 达到持久化的队列
2. rabbitmq确保持久性消息能从服务器中重启中恢复的方式是，将他们写入磁盘上的一个持久化日志文件。当发布一条持久化消息到持久交换器上时，rabbitmq会在消息提交到日志文件后才发送响应（如果之后这条消息路由到非持久化队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复）
3. 一旦你从持久化队列中消费了一条持久性消息的话(并且确认了它)，rabbitmq会在持久化日志中把这条消息标记为等待垃圾收集



# 发送方确认模式
1. 需要告诉rabbitmq将信道设置为confirm模式，而且你只能通过重新创建信道来关闭该设置。一旦信道进入confirm模式，所有在信道上发布的消息都被指派一个唯一的ID号(从1开始)。一旦消息被投递给所有匹配的队列后，信道会发送一个发送方确认模式给生产者应用程序(包括消息的唯一ID)。如果消息和队列是可持久化的，那么确认消息只会在队列将消息写入磁盘后才会发出，发送方确认模式的最大好处是他们是异步的。如果rabbitmq发生内部错误从而导致了消息的丢失，rabbitmq会发送一条nack(not acknowledged未确认)消息。就像发送方确认消息那样，只不过这次说明的是消息已经丢失


