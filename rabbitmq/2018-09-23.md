# 死信队列

1. `DLX(Dead-Letter-Exchange)`称之为死信队列。当一个消息在`Queue`中编程`死信消息(Dead Message)`之后，它能够被重新发送到另一个`Exchange`中，这个`Exchange`就是`DLX`,绑定`DLX`的队列就叫做`死信队列`
2. 消息变为死信队列
	* 消息被拒绝(`Basic.Reject/Basic.Nack`)，并且设置`requeue`参数为false
	* 消息过期
	* 队列达到最大长度

# 延迟队列

1. 
	



# ### Message acknowledgment
1. 消息回执。
	* 消费者受到Queue中的消息，但没有处理完成就宕机(或者其他情况)，这种情况会导致消息丢失，为了避免这个问题，可以要求消费者在处理完消息之后发送一个ack(回执)给rabbitmq。rabbitmq收到消息回执之后才将消息从Queue中移除。
	* 如果没有收到消息回执并检测到消费者的rabbitmq连接断开，则rabbitmq会将消息发送给其他消费者进行处理。这里不存在timeout，一个消费者处理消息时间再长也不会导致该消息被发送给其他消息者，除非他的rabbitmq连接断开。  
	* 如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的bug——Queue中堆积的消息会越来越多。消费者重启后会重复消费这些消息并重复执行业务逻辑。
2. publish message 是没有ACK的。

### Message durability
1. 可以将Queue与Message 都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的rabbitmq消息不会丢失(加入还没来及的持久化就宕机则依然会丢失)

### Prefetch count
1. 如果多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者，如果每个消息的处理时间不同，就可能导致一些消费者一直在忙，而另外一些消费者一直在空闲。可以通过设置Prefetch count来限制Queue每次发送给每个消费者的消息数，比如设置为1，则Queue每次给每个消费者发送一条消息，消费者处理完这条消息后Queue会再给该消费者发送一条消息。


